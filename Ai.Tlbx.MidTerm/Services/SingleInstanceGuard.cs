using System.Runtime.InteropServices;
#if WINDOWS
using System.Threading;
#endif

namespace Ai.Tlbx.MidTerm.Services;

/// <summary>
/// Ensures only one instance of mt.exe runs system-wide.
/// Uses named mutex on Windows, file lock on Unix.
/// </summary>
public sealed class SingleInstanceGuard : IDisposable
{
    private const string MutexName = "Global\\MidTerm";
    private const string PidFileName = "midterm.pid";

#if WINDOWS
    private Mutex? _mutex;
#else
    private FileStream? _pidFile;
#endif
    private bool _disposed;

    public static SingleInstanceGuard? TryAcquire(out string? existingInfo)
    {
        existingInfo = null;
        var guard = new SingleInstanceGuard();

        if (guard.TryAcquireInternal(out existingInfo))
        {
            return guard;
        }

        guard.Dispose();
        return null;
    }

    private bool TryAcquireInternal(out string? existingInfo)
    {
        existingInfo = null;

#if WINDOWS
        return TryAcquireWindows(out existingInfo);
#else
        return TryAcquireUnix(out existingInfo);
#endif
    }

#if WINDOWS
    private bool TryAcquireWindows(out string? existingInfo)
    {
        existingInfo = null;

        try
        {
            _mutex = new Mutex(true, MutexName, out var createdNew);

            if (createdNew)
            {
                return true;
            }

            existingInfo = "Another mt.exe instance is already running";
            _mutex.Dispose();
            _mutex = null;
            return false;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[SingleInstanceGuard] Mutex error: {ex.Message}");
            return true;
        }
    }
#else
    private bool TryAcquireUnix(out string? existingInfo)
    {
        existingInfo = null;

        var pidPath = GetPidFilePath();
        var pidDir = Path.GetDirectoryName(pidPath);

        try
        {
            if (!string.IsNullOrEmpty(pidDir) && !Directory.Exists(pidDir))
            {
                Directory.CreateDirectory(pidDir);
            }

            _pidFile = new FileStream(
                pidPath,
                FileMode.OpenOrCreate,
                FileAccess.ReadWrite,
                FileShare.None);

            // Check if there's an existing PID and if that process is still running
            _pidFile.Seek(0, SeekOrigin.Begin);
            using var reader = new StreamReader(_pidFile, leaveOpen: true);
            var content = reader.ReadToEnd().Trim();

            if (int.TryParse(content, out var existingPid) && IsProcessRunning(existingPid))
            {
                existingInfo = $"Another mt.exe instance is already running (PID: {existingPid})";
                _pidFile.Dispose();
                _pidFile = null;
                return false;
            }

            // Write our PID
            _pidFile.SetLength(0);
            _pidFile.Seek(0, SeekOrigin.Begin);
            using var writer = new StreamWriter(_pidFile, leaveOpen: true);
            writer.Write(Environment.ProcessId.ToString());
            writer.Flush();

            return true;
        }
        catch (IOException)
        {
            existingInfo = "Another mt.exe instance is already running (file locked)";
            return false;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[SingleInstanceGuard] PID file error: {ex.Message}");
            return true;
        }
    }

    private static string GetPidFilePath()
    {
        if (OperatingSystem.IsMacOS())
        {
            return "/usr/local/var/run/midterm.pid";
        }

        return "/var/run/midterm.pid";
    }

    private static bool IsProcessRunning(int pid)
    {
        try
        {
            using var process = System.Diagnostics.Process.GetProcessById(pid);
            return !process.HasExited;
        }
        catch
        {
            return false;
        }
    }
#endif

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

#if WINDOWS
        _mutex?.ReleaseMutex();
        _mutex?.Dispose();
#else
        if (_pidFile is not null)
        {
            var path = _pidFile.Name;
            _pidFile.Dispose();
            try { File.Delete(path); } catch { }
        }
#endif
    }
}
